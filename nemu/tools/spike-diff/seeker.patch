diff --git a/riscv/processor.cc b/riscv/processor.cc
index c757d42..a760ea1 100644
--- a/riscv/processor.cc
+++ b/riscv/processor.cc
@@ -963,21 +963,37 @@ void processor_t::put_csr(int which, reg_t val)
   }
 }
 
+bool difftest_dut_csr_notexist = false;
+
 // Note that get_csr is sometimes called when read side-effects should not
 // be actioned.  In other words, Spike cannot currently support CSRs with
 // side effects on reads.
 reg_t processor_t::get_csr(int which, insn_t insn, bool write, bool peek)
 {
+  if(difftest_dut_csr_notexist) {
+    difftest_dut_csr_notexist=false;
+    printf("spike:stepping DUT(nemu,npc)'s unimplemented csr\n");
+    throw trap_illegal_instruction(insn.bits());
+  }
   auto search = state.csrmap.find(which);
   if (search != state.csrmap.end()) {
     if (!peek)
       search->second->verify_permissions(insn, write);
     return search->second->read();
   }
+  printf("spike:stepping REF(spike)'s unimplemented csr\n");
   // If we get here, the CSR doesn't exist.  Unimplemented CSRs always throw
   // illegal-instruction exceptions, not virtual-instruction exceptions.
   throw trap_illegal_instruction(insn.bits());
 }
+reg_t processor_t::difftest_get_csr(int which)
+{
+  auto search = state.csrmap.find(which);
+  
+  assert(search!=state.csrmap.end());
+
+  return search->second->read();
+}
 
 reg_t illegal_instruction(processor_t UNUSED *p, insn_t insn, reg_t UNUSED pc)
 {
diff --git a/riscv/processor.h b/riscv/processor.h
index 4f357c6..0b41d9e 100644
--- a/riscv/processor.h
+++ b/riscv/processor.h
@@ -198,6 +198,7 @@ public:
   void put_csr(int which, reg_t val);
   uint32_t get_id() const { return id; }
   reg_t get_csr(int which, insn_t insn, bool write, bool peek = 0);
+  reg_t difftest_get_csr(int which);
   reg_t get_csr(int which) { return get_csr(which, insn_t(0), false, true); }
   mmu_t* get_mmu() { return mmu; }
   state_t* get_state() { return &state; }
diff --git a/riscv/sim.h b/riscv/sim.h
index 24cc244..724dc9c 100644
--- a/riscv/sim.h
+++ b/riscv/sim.h
@@ -64,6 +64,8 @@ public:
   void diff_step(uint64_t n);
   void diff_get_regs(void* diff_context);
   void diff_set_regs(void* diff_context);
+  void diff_get_csrs(void* diff_context);
+  void diff_init_csr_idx(uint32_t* csr_idx);
   void diff_memcpy(reg_t dest, void* src, size_t n);
 
 private:
